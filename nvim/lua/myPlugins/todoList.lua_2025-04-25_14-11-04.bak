-- TODO: Add option to use ripgrep
--
--ðŸ”§ Code Quality & Consistency
-- Use local state where possible instead of _G. Consider using a module table like M = {} and return it at the end.
-- Group functions better: UI, utils, ignore, cache, etc.
-- Cache repeated calls to vim.fn or vim.api if used often inside loops (vim.fn.fnamemodify, vim.fn.readfile, etc.).
-- Always check edge cases like file == nil or line:find(...) == nil.
-- âš¡ Performance
-- vim.fn.readfile() reads the entire file into memoryâ€”on big files this might be slow. Consider using io.lines.
-- Use vim.loop.fs_stat() once per file instead of twice (you use it in get_todos and then again in write_file logic).
-- In get_todos, cache the result of vim.fn.filereadable(file) to avoid calling it multiple times.
-- ðŸ§  UX/Features
-- Add a filter by TODO: category, like TODO:URGENT, TODO:FIXME, etc.
-- Add highlighting to TODO lines when opened (via extmarks or signs).
-- Let users define custom keywords or regexes to scan for (like HACK, BUG, NOTE).
-- Integrate with LSP diagnostics if needed (just for synergy).
-- ðŸ§ª Testing & Safety
-- Wrap dangerous operations (io.open, file I/O) in pcall.
-- Log errors to a log file in cache dir (optional: toggle debug mode).
-- Add a setup function where users can override default paths and options.
-- Provide a way to re-scan a single file (force update in case cache is stale).
-- âœ¨ Aesthetic
-- Use Lua string interpolation (string.format) consistently.
-- For floating UIs, consider using plenary.popup or a layout helper if the UI grows.
-- You could optionally use telescope.nvim for selecting todos with fuzzy search.

local ignore_list_file_path = vim.fn.stdpath("config") .. "/.todoList.lua"
local ignore_pattern_file_path = vim.fn.stdpath("config") .. "/.todoListPattern.lua"
local todo_list_cache = vim.fn.stdpath("cache") .. "/.todoList.lua"

local function load_file(file_path)
	local data = {}
	local ok, from_file = pcall(dofile, file_path)
	if ok and type(from_file) == "table" then
		data = from_file
	end
	return data
end

local function write_file(file, variable)
	local f = io.open(file, "w")
	if f then
		f:write("return " .. vim.inspect(variable))
		f:close()
	else
		vim.print("Error opening file: " .. file)
	end
end
_G.todo_list_use_ripgrep = false
_G.todo_list_ignore_list = load_file(ignore_list_file_path)
_G.todo_list_ignore_pattern = load_file(ignore_pattern_file_path)
_G.todo_list_cache = load_file(todo_list_cache)

local function cache_clear()
	vim.print("Clearing cache")
	_G.todo_list_cache = {}
	write_file(todo_list_cache, _G.todo_list_cache)
end

local function cache_view()
	local cache_dump = vim.inspect(_G.todo_list_cache)
	local lines = vim.split(cache_dump, "\n")

	-- Create a new scratch buffer
	local buf = vim.api.nvim_create_buf(false, true)
	vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)
	vim.api.nvim_buf_set_name(buf, "TODO Cache")

	-- Set key mapping to close the window on pressing q
	vim.api.nvim_buf_set_keymap(buf, "n", "q", "<cmd>bd!<CR>", { noremap = true, silent = true })

	-- Calculate floating window size and position
	local width = math.floor(vim.o.columns * 0.8)
	local height = math.floor(vim.o.lines * 0.8)
	local row = math.floor((vim.o.lines - height) / 2)
	local col = math.floor((vim.o.columns - width) / 2)

	-- Open the floating window
	vim.api.nvim_open_win(buf, true, {
		relative = "editor",
		width = width,
		height = height,
		row = row,
		col = col,
		style = "minimal",
		border = "rounded",
	})
end

local function display_todos(todos)
	if todos == nil or type(todos) ~= "table" then
		vim.print("Was not able to display the todos")
		return
	end
	if #todos == 0 then
		vim.print("No todos found")
		return
	end
	vim.ui.select(todos, {
		prompt = "Select a TODO to open:",
		format_item = function(todo)
			local display_string = string.format("%s:%s", todo.name, todo.text)
			return display_string
		end,
	}, function(selected)
		if selected then
			vim.cmd("e " .. selected.file)
			vim.api.nvim_win_set_cursor(0, { selected.lnum, selected.col - 1 })
		end
	end)
end

local function contains(tbl, val)
	for _, v in ipairs(tbl) do
		if vim.fn.fnamemodify(v, ":p") == vim.fn.fnamemodify(val, ":p") then
			return true
		end
	end
	return false
end

local function filter_ignore_list(files)
	local filtered = {}
	for _, file in ipairs(files) do
		if not contains(_G.todo_list_ignore_list, file) then
			table.insert(filtered, file)
		end
	end
	return filtered
end

local function filter_ignore_pattern(files)
	local filtered_files = {}
	local filter_file = false
	for _, file in ipairs(files) do
		filter_file = false
		for _, pattern in ipairs(_G.todo_list_ignore_pattern) do
			if file:find(pattern) then
				filter_file = true
			end
		end
		if not filter_file then
			table.insert(filtered_files, file)
		end
	end
	return filtered_files
end

local function get_todos_no_ripgrep_small(file) end
local function get_todos_no_ripgrep_large(file) end

local function get_todos_no_ripgrep(files)
	local todos = {}
	local file_todos, file_cache, line_todo, todo_start, todo_end
	local update_cache
	local write_cache = false
	for _, file in ipairs(files) do
		update_cache = false
		file_todos = {}
		file_cache = _G.todo_list_cache[file]

		if file_cache and file_cache.mtime > vim.loop.fs_stat(file).mtime.sec then
			file_todos = file_cache.todos
			-- Has to be inside a foor loop, otherwise the table structure gets messed up.
			for _, todo in ipairs(file_todos) do
				table.insert(todos, todo)
			end
		elseif vim.fn.filereadable(file) == 1 then
			local lines = vim.fn.readfile(file)
			for lnum, line in ipairs(lines) do
				todo_start, todo_end = line:find("TODO:")
				if todo_end then
					line_todo = {
						file = file,
						name = vim.fn.fnamemodify(file, ":t"), -- Stores the name of the file that will be displayed in the UI
						text = string.sub(line, todo_end + 1, todo_end + 1 + 128),
						lnum = lnum,
						col = todo_start,
					}
					table.insert(file_todos, line_todo)
					table.insert(todos, line_todo)
					update_cache = true
				end
			end
			if update_cache then
				_G.todo_list_cache[file] = {
					mtime = os.time(),
					todos = file_todos,
				}
				write_cache = true
			end
		else
			print("Error opening file: " .. file)
		end
	end
	if write_cache then
		write_file(todo_list_cache, _G.todo_list_cache)
	end
	return todos
end

local function get_todos_ripgrep(files)
	vim.print("Using ripgrep")

end

local function f_toggle_ripgrep()
	_G.todo_list_use_ripgrep = not _G.todo_list_use_ripgrep
	print("Ripgrep is now " .. _G.todo_list_use_ripgrep)
end

local function get_todos(files)
	if _G.todo_list_use_ripgrep then
		return get_todos_ripgrep(files)
	else
		return get_todos_no_ripgrep(files)
	end
end

local function f_current_buffer()
	local file_path = vim.api.nvim_buf_get_name(0)
	local files = { file_path }
	local todos = get_todos(files)
	display_todos(todos)
end

local function f_current_buffers()
	local bufsnrs = vim.api.nvim_list_bufs()
	local files = {}
	for _, bufnr in ipairs(bufsnrs) do
		if vim.api.nvim_buf_is_loaded(bufnr) and vim.api.nvim_buf_get_name(bufnr) ~= "" then
			table.insert(files, vim.api.nvim_buf_get_name(bufnr))
		end
	end
	local todos = get_todos(files)
	display_todos(todos)
end

local function f_folder(path)
	local cmd = "find " .. vim.fn.shellescape(path) .. " -type f"
	local files = vim.fn.systemlist(cmd)
	files = filter_ignore_pattern(files)
	files = filter_ignore_list(files)
	local todos = get_todos(files)
	display_todos(todos)
end

local function f_git()
	local current_file = vim.fn.expand("%:p:h")
	local cmd = "git -C '" .. current_file .. "' rev-parse --show-toplevel 2>/dev/null"
	local in_repo = vim.fn.system(cmd)
	if in_repo == "" then
		print("File is not in a git repository")
		return
	end

	local git_root = vim.fn.trim(in_repo)
	local git_files = {}

	cmd = "git -C " .. git_root .. " ls-files"
	local files = vim.fn.system(cmd)
	files = vim.fn.split(files, "\n")
	for i, file in ipairs(files) do
		git_files[i] = git_root .. "/" .. file
	end
	git_files = filter_ignore_pattern(git_files)
	git_files = filter_ignore_list(git_files)
	local todos = get_todos(git_files)
	display_todos(todos)
end

-- Ignore list
local function ignore_list_update()
	local f = io.open(ignore_list_file_path, "w")
	if f then
		-- This is just so that the file is formated nicely with proper indentation.
		f:write(
			"return{\n\t" .. vim.inspect(_G.todo_list_ignore_list):gsub("{ ", ""):gsub(", ", ",\n\t"):gsub(" }", "\n}")
		)

		f:close()
	else
		print("Error opening file: " .. ignore_list_file_path)
	end
end

local function f_next_todo()
	local todos = get_todos({ vim.api.nvim_buf_get_name(0) })
	local cursor_line = vim.api.nvim_win_get_cursor(0)[1]
	if #todos == 0 then
		vim.print("No todos found")
		return
	end
	local jumped = false
	for _, todo in ipairs(todos) do
		if todo.lnum > cursor_line then
			vim.api.nvim_win_set_cursor(0, { todo.lnum, todo.col })
			jumped = true
			break
		end
	end
	if not jumped then
		vim.api.nvim_win_set_cursor(0, { todos[1].lnum, todos[1].col })
	end
end

local function f_prev_todo()
	local todos = get_todos({ vim.api.nvim_buf_get_name(0) })
	if #todos == 0 then
		vim.print("No todos found")
		return
	end
	local cursor_line = vim.api.nvim_win_get_cursor(0)[1]
	local move_to = { todos[#todos].lnum, todos[#todos].col } -- Line num and col
	local jumped = false
	for _, todo in ipairs(todos) do
		if todo.lnum < cursor_line then
			move_to = { todo.lnum, todo.col }
		else
			vim.api.nvim_win_set_cursor(0, move_to)
			jumped = true
			break
		end
	end
	if not jumped then
		vim.api.nvim_win_set_cursor(0, move_to)
	end
end

local function ignore_list_add()
	local current_buffer_path = vim.fn.expand("%:p")
	if not contains(_G.todo_list_ignore_list, current_buffer_path) then
		table.insert(_G.todo_list_ignore_list, current_buffer_path)
		print("Added: " .. current_buffer_path)
		ignore_list_update()
	end
end

local function ignore_list_remove()
	local current_buffer_path = vim.fn.expand("%:p")
	local found = false
	for i, ignore_file_path in ipairs(_G.todo_list_ignore_list) do
		if ignore_file_path == current_buffer_path then
			table.remove(_G.todo_list_ignore_list, i)
			found = true
			break
		end
	end
	if found then
		print("Removed from ignore list: " .. current_buffer_path)
		ignore_list_update()
	else
		print("Did not find in igonre list: " .. current_buffer_path)
	end
end

local function ignore_list_view()
	local width = math.floor(vim.o.columns * 0.8)
	local height = math.floor(vim.o.lines * 0.8)
	local row = math.floor((vim.o.lines - height) / 2)
	local col = math.floor((vim.o.columns - width) / 2)

	local win = vim.api.nvim_open_win(0, true, {
		relative = "editor",
		width = width,
		height = height,
		row = row,
		col = col,
		style = "minimal",
		border = "rounded",
	})

	vim.api.nvim_win_call(win, function()
		vim.cmd("edit " .. vim.fn.fnameescape(ignore_list_file_path))
	end)

	local buf = vim.api.nvim_win_get_buf(win)

	vim.api.nvim_create_autocmd("WinClosed", {
		pattern = tostring(win),
		callback = function()
			_G.todo_list_ignore_list = load_file(ignore_list_file_path)
		end,
	})

	vim.api.nvim_buf_set_keymap(buf, "n", "q", "<cmd>w|bd<CR>", { noremap = true, silent = true })
end

local function ignore_pattern_view()
	local width = math.floor(vim.o.columns * 0.8)
	local height = math.floor(vim.o.lines * 0.8)
	local row = math.floor((vim.o.lines - height) / 2)
	local col = math.floor((vim.o.columns - width) / 2)

	local win = vim.api.nvim_open_win(0, true, {
		relative = "editor",
		width = width,
		height = height,
		row = row,
		col = col,
		style = "minimal",
		border = "rounded",
	})

	vim.api.nvim_win_call(win, function()
		vim.cmd("edit " .. vim.fn.fnameescape(ignore_pattern_file_path))
	end)

	local buf = vim.api.nvim_win_get_buf(win)

	vim.api.nvim_create_autocmd("WinClosed", {
		pattern = tostring(win),
		callback = function()
			_G.todo_list_ignore_pattern = load_file(ignore_pattern_file_path)
		end,
	})

	vim.api.nvim_buf_set_keymap(buf, "n", "q", "<cmd>w|bd<CR>", { noremap = true, silent = true })
end

local keymap = vim.keymap.set
local opts = { noremap = true, silent = true }
keymap("n", "<Leader>t", "<Nop>", { desc = "Todo list" })
keymap("n", "<Leader>tt", f_current_buffer, { desc = "Current buffer" })
keymap("n", "<Leader>tb", f_current_buffers, { desc = "Open buffers" })
keymap("n", "<Leader>tc", function()
	local cwd = vim.fn.getcwd()
	f_folder(cwd)
end, { desc = "Cwd" })
keymap("n", "<Leader>tg", f_git, { desc = "Current git repositorie" })
keymap("n", "<Leader>tr", f_toggle_ripgrep, { desc = "Toggle ripgrep usage" })

keymap("n", "<Leader>tn", f_next_todo, { desc = "Next TODO in buffer" })
keymap("n", "<Leader>tN", f_prev_todo, { desc = "Previous TODO in buffer" })

keymap("n", "<Leader>ti", ignore_list_add, { desc = "Add to ignore list" })
keymap("n", "<Leader>tr", ignore_list_remove, { desc = "Remove from ignore list" })
keymap("n", "<Leader>tv", ignore_list_view, { desc = "View ignore list" })
keymap("n", "<Leader>tp", ignore_pattern_view, { desc = "View ignore pattern" })

keymap("n", "<Leader>tC", cache_clear, { desc = "Clear cache" })
keymap("n", "<Leader>tV", cache_view, { desc = "View cache" })
